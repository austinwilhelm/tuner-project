<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Guitar Tuner</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background-color: #f4f4f4;
      text-align: center;
      margin-top: 50px;
    }
    h1 {
      color: #333;
    }
    #startButton {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 20px;
    }
    #startButton:hover {
      background-color: #45a049;
    }
    #note {
      font-size: 4em;
      margin: 20px 0;
    }
    #frequency {
      font-size: 2em;
      color: gray;
    }
    .tuner-status {
      font-size: 1.5em;
      padding: 20px;
      margin-top: 10px;
      display: inline-block;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      line-height: 80px;
      text-align: center;
      color: white;
    }
    .in-tune {
      background-color: green;
    }
    .sharp {
      background-color: blue;
    }
    .flat {
      background-color: red;
    }
  </style>
</head>
<body>

<h1>Guitar Tuner</h1>
<button id="startButton">Start Tuning</button>
<div id="note">---</div>
<div id="frequency">---</div>
<div id="status" class="tuner-status">---</div>

<script>
  const tuningFrequencies = [
    { note: 'E2', frequency: 82.41 },
    { note: 'A2', frequency: 110.00 },
    { note: 'D3', frequency: 146.83 },
    { note: 'G3', frequency: 196.00 },
    { note: 'B3', frequency: 246.94 },
    { note: 'E4', frequency: 329.63 }
  ];

  const noteElement = document.getElementById('note');
  const frequencyElement = document.getElementById('frequency');
  const statusElement = document.getElementById('status');
  const startButton = document.getElementById('startButton');

  let audioContext, analyser, dataArray, microphone;
  let frequencyHistory = [];
  let lastUpdate = 0;
  const smoothingWindow = 5; // Number of frequency values to average over
  const updateInterval = 200; // Update visual every 200ms

  startButton.addEventListener('click', async () => {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;

    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    microphone = audioContext.createMediaStreamSource(stream);
    microphone.connect(analyser);

    dataArray = new Float32Array(analyser.fftSize);
    detectPitch();
  });

  function detectPitch() {
    analyser.getFloatTimeDomainData(dataArray);
    const frequency = autoCorrelate(dataArray, audioContext.sampleRate);

    if (frequency !== -1) {
      frequencyHistory.push(frequency);
      if (frequencyHistory.length > smoothingWindow) {
        frequencyHistory.shift(); // Maintain a window of the most recent frequencies
      }

      const smoothedFrequency = frequencyHistory.reduce((a, b) => a + b, 0) / frequencyHistory.length;

      const currentTime = performance.now();
      if (currentTime - lastUpdate >= updateInterval) {
        const nearestNote = getNearestNote(smoothedFrequency);
        noteElement.textContent = nearestNote.note;
        frequencyElement.textContent = `${smoothedFrequency.toFixed(2)} Hz`;
        updateTuningStatus(smoothedFrequency, nearestNote.frequency);
        lastUpdate = currentTime;
      }
    }

    requestAnimationFrame(detectPitch);
  }

  function autoCorrelate(buffer, sampleRate) {
    let SIZE = buffer.length;
    let maxSamples = Math.floor(SIZE / 2);
    let bestOffset = -1;
    let bestCorrelation = 0;
    let rms = 0;
    let foundGoodCorrelation = false;
    let correlations = new Array(maxSamples);

    for (let i = 0; i < SIZE; i++) {
      rms += buffer[i] * buffer[i];
    }
    rms = Math.sqrt(rms / SIZE);

    if (rms < 0.01) return -1;

    let lastCorrelation = 1;
    for (let offset = 0; offset < maxSamples; offset++) {
      let correlation = 0;

      for (let i = 0; i < maxSamples; i++) {
        correlation += Math.abs(buffer[i] - buffer[i + offset]);
      }

      correlation = 1 - (correlation / maxSamples);
      correlations[offset] = correlation;

      if (correlation > 0.9 && correlation > lastCorrelation) {
        foundGoodCorrelation = true;
        if (correlation > bestCorrelation) {
          bestCorrelation = correlation;
          bestOffset = offset;
        }
      } else if (foundGoodCorrelation) {
        let shift = (correlations[bestOffset + 1] - correlations[bestOffset - 1]) / correlations[bestOffset];
        return sampleRate / (bestOffset + 8 * shift);
      }
      lastCorrelation = correlation;
    }
    if (bestCorrelation > 0.01) {
      return sampleRate / bestOffset;
    }
    return -1;
  }

  function getNearestNote(frequency) {
    let minDiff = Infinity;
    let closestNote = null;

    tuningFrequencies.forEach(tuning => {
      const diff = Math.abs(frequency - tuning.frequency);
      if (diff < minDiff) {
        minDiff = diff;
        closestNote = tuning;
      }
    });

    return closestNote;
  }

  function updateTuningStatus(frequency, targetFrequency) {
    const tolerance = 1.5; // Hz tolerance for determining in tune, flat, or sharp
    const difference = frequency - targetFrequency;

    if (Math.abs(difference) <= tolerance) {
      statusElement.textContent = 'In Tune';
      statusElement.className = 'tuner-status in-tune';
    } else if (difference > tolerance) {
      statusElement.textContent = 'Sharp';
      statusElement.className = 'tuner-status sharp';
    } else if (difference < -tolerance) {
      statusElement.textContent = 'Flat';
      statusElement.className = 'tuner-status flat';
    }
  }
</script>

</body>
</html>
